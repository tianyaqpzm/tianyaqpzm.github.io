

# 动态规划



### 三要素：

* 定义状态： 
  * 比如一个字符串的状态，通常是 `dp[i]` 表示字符串 s 以 i 结尾的 ....。 
  * 比如两个字符串的状态，通常是 `dp[i][j]` 表示字符串 `s1` 以 `i `结尾，`s2` 以 `j `结尾的 ....
  * 同一个字符串，定义两个变量：起点(终点)索引+ 子串长度；起点坐标+终点坐标`s[start][end]`
  * 

那么状态定义就是 f(start, end)，含义是子串 s[start:end+1]的最长回文子串，那么答案就是 f(0, len(s) - 1)

> s[start:end+1] 指的是包含 s[start]，而不包含 s[end+1] 的连续子串。

 f(i, j) 表示机器人到达点 (i,j) 的总的路径数
d[col][row] = d[col - 1][row] + d[col][row - 1]


* 临界条件+ 转移方程：动态规划中当前阶段的状态往往是上一阶段状态和上一阶段决策的结果

* 枚举状态：

  

### 举例：

爬楼梯问题中，如果我们用 f(n) 表示爬 n 级台阶有多少种方法的话，那么：

```
f(1) 与 f(2) 就是【边界】
f(n) = f(n-1) + f(n-2) 就是【状态转移公式】
----
dp[0] 与 dp[1] 就是【边界】
dp[n] = dp[n - 1] + dp[n - 2] 就是【状态转移方程】
```

最长回文子串

```
 f(start, end) 含义变成子串 s[start:end+1]的最长回文子串，且必须包含 start 和 end
 f(i,j)=f(i+1,j−1) and s[i] == s[j]


```



#### 正则表达式匹配  难度困难。

以我们分析的 f(s_start, s_end, p_start, p_end) 来说，含义是子串 p1[p_start:p_end+1] 是否可以匹配字符串 s[s_start:s_end+1]。

实际上，我们可以定义更简单的方式，那就是 f(s_end, p_end)，含义是子串 p1[:p_end+1] 是否可以匹配字符串 s[:s_end+1]。也就是说固定起点为索引 0，这同样也是一个**很常见的技巧，请务必掌握。**







![20210117171307407](REAMME/20210117171307407.png)

[参考](https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html#_01-%E8%83%8C%E5%8C%85)




# 关键点
1. 状态定义
2. 状态转移方程
3. 状态枚举

70.爬楼梯
一个人爬楼梯，每次只能爬 1 个或 2 个台阶，假设有 n 个台阶，那么这个人有多少种不同的爬楼梯方法？

### 思路
由于第 n 级台阶一定是从 n - 1 级台阶或者 n - 2 级台阶来的，因此到第 n 级台阶的数目就是 到第 n - 1 级台阶的数目加上到第 n - 1 级台阶的数目。

$$
dp[i]: 第i级台阶爬楼梯的方法 \\
  dp[i]=\left
  \{
  \begin{aligned}
  dp[i-1] + dp[i-2] && i > 2 \\
  0 & & i = 0,1,2 \\
  \end{aligned}
  \right.
$$



1.   零钱兑换
给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。

你可以认为每种硬币的数量是无限的。

$$
   f(i, j) 表示用 coins 的前 i 项找 j 元需要的最少硬币数。那么答案就是 f(len(coins) - 1, amount)。 \\
   
   而这道题的核心在于 coins[i] 选择与否其实没有那么重要，重要的其实是选择的 coins 一共有多少钱。 
因此我们可以定义 :\\
f(i, j) 表示选择了 coins 的前 i 项（怎么选的不关心），且组成 j 元需要的最少硬币数。 \\
dp[i][j]：使用coins[0...i]这么多硬币的情况下，组成目标金额为j时的最少硬币数量\\
  dp[i][j]=\left
  \{
  \begin{aligned}
   min( dp[i-1][j], dp[i][j-coin[i]] +1) && j >= coin[i] \\
                         amount+1        && j < coin[i] \\
  \end{aligned}
  \right.
$$

这个动态转移方程转换成了01背包问题
不选当前的coins[i] 用i-1个硬币组成金额为jj最少硬币数量：dp[i-1][j]
选当前的coins[i] 用i个硬币组成金额为j最少硬币数量：dp[i][j-coins[i]]+1

一维优化
$$
 dp[j]：凑足总额为j所需钱币的最少个数为dp[j]. \\
 
 dp[j]= \left
  \{
  \begin{aligned}
 min( p[j - coins[i]] + 1,dp[j]) && j >= coin[i] \\
                         none        && j < coin[i] \\
  \end{aligned}
  \right.
 
$$


> 由组合原理，coins 的所有选择状态是 $2^n$。状态总数就是 i 和 j 的取值的笛卡尔积，也就是 2^len(coins) * (amount + 1)。
> 
> 减 1 是因为存在 0 元的情况。


## 关键点：
倒叙遍历是为了保证物品i只被放入一次！。但如果一旦正序遍历了，那么物品0就会被重复加入多次！


举一个例子：物品0的重量weight[0] = 1，价值value[0] = 15

如果正序遍历
dp[1] = dp[1 - weight[0]] + value[0] = 15
dp[2] = dp[2 - weight[0]] + value[0] = 30

此时dp[2]就已经是30了，意味着物品0，被放入了两次，所以不能正序遍历。

为什么倒叙遍历，就可以保证物品只放入一次呢？
倒叙就是先算dp[2]
dp[2] = dp[2 - weight[0]] + value[0] = 15 （dp数组已经都初始化为0）
dp[1] = dp[1 - weight[0]] + value[0] = 15



一维数组 两个嵌套for循环的顺序，代码中是先遍历物品嵌套遍历背包容量，那可不可以先遍历背包容量嵌套遍历物品呢？

因为一维dp的写法，背包容量一定是要倒序遍历（原因上面已经讲了），如果遍历背包容量放在上一层，那么每个dp[j]就只会放入一个物品，即：背包里只放入了一个物品。
 dp[j]：凑足总额为j所需钱币的最少个数为dp[j]. 
> 正序 可以（已验证）， 倒序不可以（待验证）
> 



## 动态规划法
### 01背包问题
1. [动态规划解决01背包问题（java实现）](https://blog.csdn.net/qq_22222499/article/details/71017501)
> 区分第i个物品的所在的下标～～～～～

2. 遇到问题思考的方式
    首先想到的，一般是穷举法，一个一个地试，对于数目小的例子适用，如果容量增大，物品增多，这种方法就无用武之地了。
    　　其次，可以先把价值最大的物体放入，这已经是贪婪算法的雏形了。如果不添加某些特定条件，结果未必可行。
    　　最后，就是动态规划的思路了。先将原始问题一般化，欲求背包能够获得的总价值，即欲求前i个物体放入容量为m（kg）背包的最大价值c[i][m]——使用一个数组来存储最大价值
    [01背包问题吐血详解](https://blog.csdn.net/u013445530/article/details/40210587)

3. 初始化细节
有的题目则并没有要求必须把背包装满。。。。
如果要求背包恰好装满，那么此时只有容量为0的背包可能被价值为0的nothing“恰好装满”，其它容量的背包均没有合法的解，属于未定义的状态，它们的值就都应该是-∞了



篮球比赛：

dp[i][j][z]:
当前战斗力之和，
dp[0][i]
dp[1][i]

dp[i]= d

dp[]
55/2
从10个数中找5个 和接近 总数/2
dp[i][j] =  
d[i-1]

总数/2 = n/2
1、如果 i 放入后，战力比总数/2 大，则一定不能放
2、如果 i

dp[i][n] =  d[i-1][n], d[i-1][n + x[i-1]]
i: 这一组的人数

d[0][0] =1

// d[1][10000] = 1
// d[0] d[1] d[2] d[3]
// d[4][100000] 一旦选了j，剩余战力就要减少
// d[i][k]一组i个人的 战力之和为k，的方式为只有1 代表该组选择i
// d[i][k] = if(d[i-1][k-a[j]]) ==1 则为1

测试
$$
 dp[i][j]：凑足总额为j所需钱币的最少个数为dp[j]. \\
 
 dp[j]= \left
  \{
  \begin{aligned}
 min( p[j - coins[i]] + 1,dp[j]) && j >= coin[i] \\
                         none        && j < coin[i] \\
  \end{aligned}
  \right.
 
$$